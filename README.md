# [Pocket](https://github.com/TypingHare/pocket)

## Basics

Pocket is a weakly and statically typed scripting language designed to simplify small tasks by eliminating unnecessary overhead.

It follows a functional programming style, where functions are treated as first-class citizens. You define a function by creating a lambda expression (also known as an anonymous function) and assigning it to a variable, just like you would with any other value.

```
// Define a function with no parameters
val helloworld = { println("Hello World!") }

// Define a function that takes a parameter
val increment = { x => x + 1 };
```

Conditional branches in Pocket may look similar to those in C-like languages, but they work a bit differently under the hood. In Pocket, both the then and else branches are functions with no parameters. When the condition is evaluated, only the chosen branch gets called. The result of that function call becomes the value of the entire if expression, which means it can be assigned directly to a variable.

```
val number = 7;
val parity = if (number % 2 == 0) { "Even" } else { "Odd" };
println(parity);
```

Pocket supports a pipe operator `->`, which lets you pass a value into a function that takes a single parameter. It helps make chained function calls more readable:

```
val square = { x => x * x };
val sum = { y, z => y + z };
sum(5, 3) -> square -> println;  // 64
```

In this example, `sum(5, 3)` evaluates to `8`, which is then passed to `square`, resulting in `64`, and finally printed using `println`.

Pocket supports partial function application using the `&` symbol:

```
val sum = { x, y => x + y };
val incr = &sum(1);
incr(5) -> println;  // 6
```

Here, `&sum(1)` creates a new function by partially applying the first argument of `sum`. The `&` tells Pocket that this is a partial application, so it returns a function that takes the remaining arguments—in this case, just one.

Pocket doesn’t have traditional `for` or `while` loops. Instead, you can create a generator object using the `yield` keyword, followed by four functions: `initializer`, `isAlive`, `toYield`, and `updater`. For example, the code below prints `Count: 1` through `Count: 5`: 

```
val range = { start, end =>
    yield { start } identity { v => v + 1 } { v => v < end }
};
range(1, 6) -> &each { x => println("Count: " + x) };
```

In the future, Pocket will include built-in generator functions, so developers won’t need to define them manually.

> [!NOTE]
> The current version yet has a type system, which will be implemented in the upcoming version.

## Installation

Pocket requires [JRE](https://www.java.com/en/download/manual.jsp) and [Node.js](https://nodejs.org/en/download). Install Pocket with `npm` (or other Node.js package managers).

```shell
$ npm install -g @typinghre/pocket
```

## Implementation

In its current version, Pocket doesn't have its own runtime. Instead, it transpiles the source code into JavaScript (Using CommonJS) and runs it with Node.js.

The lexer and the parser are generated by ANTLR, which builds the concrete syntax tree (CST) from the source code. Each file is first converted into a CST, then transformed into an abstract syntax tree (AST) using `ModuleFnBuilder`, which produces a `ModuleFn` AST node. Imported files are parsed recursively in the same manner. All `ModuleFn` nodes are then collected into a single `Program` node, along with a dependency tree that captures how the modules relate to one another.

To walk through the AST, there's an abstract `Visitor` class. The `JavaScriptVisitor` extends it and implements all the necessary methods to convert the AST into a JavaScript program.

For more details, see:

- [Lexer](src/main/antlr/PocketLexer.g4)
- [Parser](src/main/antlr/PocketParser.g4)
- [ModuleFnBuilder](src/main/java/pocket/ast/builder/ModuleFnBuilder.kt)
- [Visitor](src/main/java/pocket/ast/visitor/Visitor.kt)
- [JavaScriptVisitor](src/main/java/pocket/transpiler/js/JavaScriptVisitor.kt)

## Story

Back in 2020, I was looking for a scripting language to handle small tasks like moving files and clearing the cache on a cloud server. At the time, Python was getting really popular—everyone was recommending it—so I ended up using it to write a bunch of scripts. But honestly, I never really liked Python’s syntax. It didn’t click with me, especially since it lacks good support for functional programming and static types.

Since I do a lot of coding, I started drafting my own scripting language with all the features and syntax I wanted for these kinds of small tasks. The problem was, my background wasn’t in computer science, so I struggled a lot trying to learn things like lexical and syntax analysis on my own. Around that time, I was also watching [Pokémon anime](https://en.wikipedia.org/wiki/Pokémon_the_Series:_Diamond_and_Pearl), so I decided to call the language "Pocket"—the idea being that it could handle simple jobs quickly, with minimal fuss and overhead.

Over the years, I kept refining my drafts. After moving to the U.S. for college and learning more about programming languages and compilers, I finally decided to bring Pocket to life. It felt amazing to see it working.